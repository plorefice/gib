use super::bus::MemR;
use super::CPU;

const OPCODE_SIZES: [u8; 256] = [
    1, 3, 1, 1, 1, 1, 2, 1, 3, 1, 1, 1, 1, 1, 2, 1, 2, 3, 1, 1, 1, 1, 2, 1, 2, 1, 1, 1, 1, 1, 2, 1,
    2, 3, 1, 1, 1, 1, 2, 1, 2, 1, 1, 1, 1, 1, 2, 1, 2, 3, 1, 1, 1, 1, 2, 1, 2, 1, 1, 1, 1, 1, 2, 1,
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
    1, 1, 3, 3, 3, 1, 2, 1, 1, 1, 3, 1, 3, 3, 2, 1, 1, 1, 3, 1, 3, 1, 2, 1, 1, 1, 3, 1, 3, 1, 2, 1,
    2, 1, 2, 1, 1, 1, 2, 1, 2, 1, 3, 1, 1, 1, 2, 1, 2, 1, 2, 1, 1, 1, 2, 1, 2, 1, 3, 1, 1, 1, 2, 1,
];

const OPCODE_MNEMONICS: [&str; 256] = [
    "nop",
    "ld bc,d16",
    "ld (bc),a",
    "inc bc",
    "inc b",
    "dec b",
    "ld b,d8",
    "rlca",
    "ld (a16),sp",
    "add hl,bc",
    "ld a,(bc)",
    "dec bc",
    "inc c",
    "dec c",
    "ld c,d8",
    "rrca",
    "stop 0",
    "ld de,d16",
    "ld (de),a",
    "inc de",
    "inc d",
    "dec d",
    "ld d,d8",
    "rla",
    "jr r8",
    "add hl,de",
    "ld a,(de)",
    "dec de",
    "inc e",
    "dec e",
    "ld e,d8",
    "rra",
    "jr nz,r8",
    "ld hl,d16",
    "ld (hl+),a",
    "inc hl",
    "inc h",
    "dec h",
    "ld h,d8",
    "daa",
    "jr z,r8",
    "add hl,hl",
    "ld a,(hl+)",
    "dec hl",
    "inc l",
    "dec l",
    "ld l,d8",
    "cpl",
    "jr nc,r8",
    "ld sp,d16",
    "ld (hl-),a",
    "inc sp",
    "inc (hl)",
    "dec (hl)",
    "ld (hl),d8",
    "scf",
    "jr c,r8",
    "add hl,sp",
    "ld a,(hl-)",
    "dec sp",
    "inc a",
    "dec a",
    "ld a,d8",
    "ccf",
    "ld b,b",
    "ld b,c",
    "ld b,d",
    "ld b,e",
    "ld b,h",
    "ld b,l",
    "ld b,(hl)",
    "ld b,a",
    "ld c,b",
    "ld c,c",
    "ld c,d",
    "ld c,e",
    "ld c,h",
    "ld c,l",
    "ld c,(hl)",
    "ld c,a",
    "ld d,b",
    "ld d,c",
    "ld d,d",
    "ld d,e",
    "ld d,h",
    "ld d,l",
    "ld d,(hl)",
    "ld d,a",
    "ld e,b",
    "ld e,c",
    "ld e,d",
    "ld e,e",
    "ld e,h",
    "ld e,l",
    "ld e,(hl)",
    "ld e,a",
    "ld h,b",
    "ld h,c",
    "ld h,d",
    "ld h,e",
    "ld h,h",
    "ld h,l",
    "ld h,(hl)",
    "ld h,a",
    "ld l,b",
    "ld l,c",
    "ld l,d",
    "ld l,e",
    "ld l,h",
    "ld l,l",
    "ld l,(hl)",
    "ld l,a",
    "ld (hl),b",
    "ld (hl),c",
    "ld (hl),d",
    "ld (hl),e",
    "ld (hl),h",
    "ld (hl),l",
    "halt",
    "ld (hl),a",
    "ld a,b",
    "ld a,c",
    "ld a,d",
    "ld a,e",
    "ld a,h",
    "ld a,l",
    "ld a,(hl)",
    "ld a,a",
    "add a,b",
    "add a,c",
    "add a,d",
    "add a,e",
    "add a,h",
    "add a,l",
    "add a,(hl)",
    "add a,a",
    "adc a,b",
    "adc a,c",
    "adc a,d",
    "adc a,e",
    "adc a,h",
    "adc a,l",
    "adc a,(hl)",
    "adc a,a",
    "sub b",
    "sub c",
    "sub d",
    "sub e",
    "sub h",
    "sub l",
    "sub (hl)",
    "sub a",
    "sbc a,b",
    "sbc a,c",
    "sbc a,d",
    "sbc a,e",
    "sbc a,h",
    "sbc a,l",
    "sbc a,(hl)",
    "sbc a,a",
    "and b",
    "and c",
    "and d",
    "and e",
    "and h",
    "and l",
    "and (hl)",
    "and a",
    "xor b",
    "xor c",
    "xor d",
    "xor e",
    "xor h",
    "xor l",
    "xor (hl)",
    "xor a",
    "or b",
    "or c",
    "or d",
    "or e",
    "or h",
    "or l",
    "or (hl)",
    "or a",
    "cp b",
    "cp c",
    "cp d",
    "cp e",
    "cp h",
    "cp l",
    "cp (hl)",
    "cp a",
    "ret nz",
    "pop bc",
    "jp nz,a16",
    "jp a16",
    "call nz,a16",
    "push bc",
    "add a,d8",
    "rst 00h",
    "ret z",
    "ret",
    "jp z,a16",
    "prefix cb",
    "call z,a16",
    "call a16",
    "adc a,d8",
    "rst 08h",
    "ret nc",
    "pop de",
    "jp nc,a16",
    "-",
    "call nc,a16",
    "push de",
    "sub d8",
    "rst 10h",
    "ret c",
    "reti",
    "jp c,a16",
    "-",
    "call c,a16",
    "-",
    "sbc a,d8",
    "rst 18h",
    "ldh (a8),a",
    "pop hl",
    "ld (c),a",
    "-",
    "-",
    "push hl",
    "and d8",
    "rst 20h",
    "add sp,r8",
    "jp (hl)",
    "ld (a16),a",
    "-",
    "-",
    "-",
    "xor d8",
    "rst 28h",
    "ldh a,(a8)",
    "pop af",
    "ld a,(c)",
    "di",
    "-",
    "push af",
    "or d8",
    "rst 30h",
    "ld hl,sp+r8",
    "ld sp,hl",
    "ld a,(a16)",
    "ei",
    "-",
    "-",
    "cp d8",
    "rst 38h",
];

#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub enum Immediate {
    Imm8(u8),
    Imm16(u16),
}

#[derive(Default, Debug, Copy, Clone, PartialEq, Eq)]
pub struct Instruction {
    pub opcode: u8,
    pub mnemonic: &'static str,
    pub imm: Option<Immediate>,
    pub size: u8,
}

impl CPU {
    pub fn disasm(&self, mem: &impl MemR, addr: u16) -> Instruction {
        let opcode = mem.read::<u8>(addr);
        let size = OPCODE_SIZES[opcode as usize];

        let imm: Option<Immediate> = match size {
            1 => None,
            2 => Some(Immediate::Imm8(mem.read::<u8>(addr + 1))),
            3 => Some(Immediate::Imm16(mem.read::<u16>(addr + 1))),
            _ => unreachable!(),
        };

        Instruction {
            opcode,
            mnemonic: OPCODE_MNEMONICS[opcode as usize],
            imm,
            size,
        }
    }
}
